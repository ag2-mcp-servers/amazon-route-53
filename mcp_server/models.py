# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-28T13:25:24+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, List, Optional

from pydantic import BaseModel, Field, RootModel, conint, constr


class ARN(RootModel[constr(pattern=r'.*\S.*', min_length=20, max_length=2048)]):
    root: constr(pattern=r'.*\S.*', min_length=20, max_length=2048)


class AWSAccountID(RootModel[str]):
    root: str


class AccountLimitType(Enum):
    MAX_HEALTH_CHECKS_BY_OWNER = 'MAX_HEALTH_CHECKS_BY_OWNER'
    MAX_HOSTED_ZONES_BY_OWNER = 'MAX_HOSTED_ZONES_BY_OWNER'
    MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER = 'MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER'
    MAX_REUSABLE_DELEGATION_SETS_BY_OWNER = 'MAX_REUSABLE_DELEGATION_SETS_BY_OWNER'
    MAX_TRAFFIC_POLICIES_BY_OWNER = 'MAX_TRAFFIC_POLICIES_BY_OWNER'


class ActivateKeySigningKeyRequest(BaseModel):
    pass


class AlarmName(RootModel[constr(min_length=1, max_length=256)]):
    root: constr(min_length=1, max_length=256)


class AliasHealthEnabled(RootModel[bool]):
    root: bool


class AssociateVPCComment(RootModel[str]):
    root: str


class ChangeAction(Enum):
    CREATE = 'CREATE'
    DELETE = 'DELETE'
    UPSERT = 'UPSERT'


class ChangeId(RootModel[constr(min_length=1, max_length=6500)]):
    root: constr(min_length=1, max_length=6500)


class ChangeStatus(Enum):
    PENDING = 'PENDING'
    INSYNC = 'INSYNC'


class ChangeTagsForResourceResponse(BaseModel):
    pass


class Cidr(RootModel[constr(pattern=r'.*\S.*', min_length=1, max_length=50)]):
    root: constr(pattern=r'.*\S.*', min_length=1, max_length=50)


class CidrBlockInUseException(RootModel[Any]):
    root: Any


class CidrCollectionAlreadyExistsException(RootModel[Any]):
    root: Any


class CidrCollectionChangeAction(Enum):
    PUT = 'PUT'
    DELETE_IF_EXISTS = 'DELETE_IF_EXISTS'


class CidrCollectionInUseException(RootModel[Any]):
    root: Any


class CidrCollectionVersionMismatchException(RootModel[Any]):
    root: Any


class CidrList(RootModel[List[Cidr]]):
    root: List[Cidr] = Field(..., max_length=1000, min_length=1)


class CidrLocationNameDefaultAllowed(
    RootModel[constr(pattern=r'[0-9A-Za-z_\-\*]+', min_length=1, max_length=16)]
):
    root: constr(pattern=r'[0-9A-Za-z_\-\*]+', min_length=1, max_length=16)


class CidrLocationNameDefaultNotAllowed(
    RootModel[constr(pattern=r'[0-9A-Za-z_\-]+', min_length=1, max_length=16)]
):
    root: constr(pattern=r'[0-9A-Za-z_\-]+', min_length=1, max_length=16)


class CidrNonce(RootModel[constr(pattern=r'\p{ASCII}+', min_length=1, max_length=64)]):
    root: constr(pattern=r'\p{ASCII}+', min_length=1, max_length=64)


class CloudWatchLogsLogGroupArn(RootModel[str]):
    root: str


class CloudWatchRegion(Enum):
    us_east_1 = 'us-east-1'
    us_east_2 = 'us-east-2'
    us_west_1 = 'us-west-1'
    us_west_2 = 'us-west-2'
    ca_central_1 = 'ca-central-1'
    eu_central_1 = 'eu-central-1'
    eu_central_2 = 'eu-central-2'
    eu_west_1 = 'eu-west-1'
    eu_west_2 = 'eu-west-2'
    eu_west_3 = 'eu-west-3'
    ap_east_1 = 'ap-east-1'
    me_south_1 = 'me-south-1'
    me_central_1 = 'me-central-1'
    ap_south_1 = 'ap-south-1'
    ap_south_2 = 'ap-south-2'
    ap_southeast_1 = 'ap-southeast-1'
    ap_southeast_2 = 'ap-southeast-2'
    ap_southeast_3 = 'ap-southeast-3'
    ap_northeast_1 = 'ap-northeast-1'
    ap_northeast_2 = 'ap-northeast-2'
    ap_northeast_3 = 'ap-northeast-3'
    eu_north_1 = 'eu-north-1'
    sa_east_1 = 'sa-east-1'
    cn_northwest_1 = 'cn-northwest-1'
    cn_north_1 = 'cn-north-1'
    af_south_1 = 'af-south-1'
    eu_south_1 = 'eu-south-1'
    eu_south_2 = 'eu-south-2'
    us_gov_west_1 = 'us-gov-west-1'
    us_gov_east_1 = 'us-gov-east-1'
    us_iso_east_1 = 'us-iso-east-1'
    us_iso_west_1 = 'us-iso-west-1'
    us_isob_east_1 = 'us-isob-east-1'
    ap_southeast_4 = 'ap-southeast-4'


class CollectionName(
    RootModel[constr(pattern=r'[0-9A-Za-z_\-]+', min_length=1, max_length=64)]
):
    root: constr(pattern=r'[0-9A-Za-z_\-]+', min_length=1, max_length=64)


class CollectionVersion(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class ComparisonOperator(Enum):
    GreaterThanOrEqualToThreshold = 'GreaterThanOrEqualToThreshold'
    GreaterThanThreshold = 'GreaterThanThreshold'
    LessThanThreshold = 'LessThanThreshold'
    LessThanOrEqualToThreshold = 'LessThanOrEqualToThreshold'


class ConcurrentModification(RootModel[Any]):
    root: Any


class ConflictingDomainExists(RootModel[Any]):
    root: Any


class ConflictingTypes(RootModel[Any]):
    root: Any


class CreateCidrCollectionRequest(BaseModel):
    CallerReference: CidrNonce
    Name: CollectionName


class DNSName(RootModel[constr(max_length=1024)]):
    root: constr(max_length=1024)


class DNSRCode(RootModel[str]):
    root: str


class DNSSECNotFound(RootModel[Any]):
    root: Any


class DeactivateKeySigningKeyRequest(BaseModel):
    pass


class DelegationSetAlreadyCreated(RootModel[Any]):
    root: Any


class DelegationSetAlreadyReusable(RootModel[Any]):
    root: Any


class DelegationSetInUse(RootModel[Any]):
    root: Any


class DelegationSetNameServers(RootModel[List[DNSName]]):
    root: List[DNSName] = Field(..., min_length=1)


class DelegationSetNotAvailable(RootModel[Any]):
    root: Any


class DelegationSetNotReusable(RootModel[Any]):
    root: Any


class DeleteCidrCollectionRequest(BaseModel):
    pass


class DeleteCidrCollectionResponse(BaseModel):
    pass


class DeleteHealthCheckRequest(BaseModel):
    pass


class DeleteHealthCheckResponse(BaseModel):
    pass


class DeleteHostedZoneRequest(BaseModel):
    pass


class DeleteKeySigningKeyRequest(BaseModel):
    pass


class DeleteQueryLoggingConfigRequest(BaseModel):
    pass


class DeleteQueryLoggingConfigResponse(BaseModel):
    pass


class DeleteReusableDelegationSetRequest(BaseModel):
    pass


class DeleteReusableDelegationSetResponse(BaseModel):
    pass


class DeleteTrafficPolicyInstanceRequest(BaseModel):
    pass


class DeleteTrafficPolicyInstanceResponse(BaseModel):
    pass


class DeleteTrafficPolicyRequest(BaseModel):
    pass


class DeleteTrafficPolicyResponse(BaseModel):
    pass


class DeleteVPCAssociationAuthorizationResponse(BaseModel):
    pass


class DimensionField(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class DisableHostedZoneDNSSECRequest(BaseModel):
    pass


class Disabled(RootModel[bool]):
    root: bool


class DisassociateVPCComment(RootModel[str]):
    root: str


class EnableHostedZoneDNSSECRequest(BaseModel):
    pass


class EnableSNI(RootModel[bool]):
    root: bool


class EvaluationPeriods(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class FailureThreshold(RootModel[conint(ge=1, le=10)]):
    root: conint(ge=1, le=10)


class FullyQualifiedDomainName(RootModel[constr(max_length=255)]):
    root: constr(max_length=255)


class GeoLocationContinentCode(RootModel[constr(min_length=2, max_length=2)]):
    root: constr(min_length=2, max_length=2)


class GeoLocationContinentName(RootModel[constr(min_length=1, max_length=32)]):
    root: constr(min_length=1, max_length=32)


class GeoLocationCountryCode(RootModel[constr(min_length=1, max_length=2)]):
    root: constr(min_length=1, max_length=2)


class GeoLocationCountryName(RootModel[constr(min_length=1, max_length=64)]):
    root: constr(min_length=1, max_length=64)


class GeoLocationSubdivisionCode(RootModel[constr(min_length=1, max_length=3)]):
    root: constr(min_length=1, max_length=3)


class GeoLocationSubdivisionName(RootModel[constr(min_length=1, max_length=64)]):
    root: constr(min_length=1, max_length=64)


class GetAccountLimitRequest(BaseModel):
    pass


class GetChangeRequest(BaseModel):
    pass


class GetCheckerIpRangesRequest(BaseModel):
    pass


class GetDNSSECRequest(BaseModel):
    pass


class GetGeoLocationRequest(BaseModel):
    pass


class GetHealthCheckCountRequest(BaseModel):
    pass


class GetHealthCheckLastFailureReasonRequest(BaseModel):
    pass


class GetHealthCheckRequest(BaseModel):
    pass


class GetHealthCheckStatusRequest(BaseModel):
    pass


class GetHostedZoneCountRequest(BaseModel):
    pass


class GetHostedZoneLimitRequest(BaseModel):
    pass


class GetHostedZoneRequest(BaseModel):
    pass


class GetQueryLoggingConfigRequest(BaseModel):
    pass


class GetReusableDelegationSetLimitRequest(BaseModel):
    pass


class GetReusableDelegationSetRequest(BaseModel):
    pass


class GetTrafficPolicyInstanceCountRequest(BaseModel):
    pass


class GetTrafficPolicyInstanceRequest(BaseModel):
    pass


class GetTrafficPolicyRequest(BaseModel):
    pass


class HealthCheckAlreadyExists(RootModel[Any]):
    root: Any


class HealthCheckCount(RootModel[int]):
    root: int


class HealthCheckId(RootModel[constr(max_length=64)]):
    root: constr(max_length=64)


class HealthCheckInUse(RootModel[Any]):
    root: Any


class HealthCheckNonce(RootModel[constr(min_length=1, max_length=64)]):
    root: constr(min_length=1, max_length=64)


class HealthCheckRegion(Enum):
    us_east_1 = 'us-east-1'
    us_west_1 = 'us-west-1'
    us_west_2 = 'us-west-2'
    eu_west_1 = 'eu-west-1'
    ap_southeast_1 = 'ap-southeast-1'
    ap_southeast_2 = 'ap-southeast-2'
    ap_northeast_1 = 'ap-northeast-1'
    sa_east_1 = 'sa-east-1'


class HealthCheckRegionList(RootModel[List[HealthCheckRegion]]):
    root: List[HealthCheckRegion] = Field(..., max_length=64, min_length=3)


class HealthCheckType(Enum):
    HTTP = 'HTTP'
    HTTPS = 'HTTPS'
    HTTP_STR_MATCH = 'HTTP_STR_MATCH'
    HTTPS_STR_MATCH = 'HTTPS_STR_MATCH'
    TCP = 'TCP'
    CALCULATED = 'CALCULATED'
    CLOUDWATCH_METRIC = 'CLOUDWATCH_METRIC'
    RECOVERY_CONTROL = 'RECOVERY_CONTROL'


class HealthCheckVersion(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class HealthCheckVersionMismatch(RootModel[Any]):
    root: Any


class HealthThreshold(RootModel[conint(ge=0, le=256)]):
    root: conint(ge=0, le=256)


class HostedZoneAlreadyExists(RootModel[Any]):
    root: Any


class HostedZoneCount(RootModel[int]):
    root: int


class HostedZoneLimitType(Enum):
    MAX_RRSETS_BY_ZONE = 'MAX_RRSETS_BY_ZONE'
    MAX_VPCS_ASSOCIATED_BY_ZONE = 'MAX_VPCS_ASSOCIATED_BY_ZONE'


class HostedZoneNotEmpty(RootModel[Any]):
    root: Any


class HostedZoneNotFound(RootModel[Any]):
    root: Any


class HostedZoneNotPrivate(RootModel[Any]):
    root: Any


class HostedZoneOwningService(RootModel[constr(max_length=128)]):
    root: constr(max_length=128)


class HostedZonePartiallyDelegated(RootModel[Any]):
    root: Any


class HostedZoneRRSetCount(RootModel[int]):
    root: int


class IPAddress(
    RootModel[
        constr(
            pattern=r'(^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$|^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$)',
            max_length=45,
        )
    ]
):
    root: constr(
        pattern=r'(^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$|^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$)',
        max_length=45,
    )


class IPAddressCidr(RootModel[str]):
    root: str


class IncompatibleVersion(RootModel[Any]):
    root: Any


class InsufficientCloudWatchLogsResourcePolicy(RootModel[Any]):
    root: Any


class InsufficientDataHealthStatus(Enum):
    Healthy = 'Healthy'
    Unhealthy = 'Unhealthy'
    LastKnownStatus = 'LastKnownStatus'


class InvalidArgument(RootModel[Any]):
    root: Any


class InvalidChangeBatch(RootModel[Any]):
    root: Any


class InvalidDomainName(RootModel[Any]):
    root: Any


class InvalidInput(RootModel[Any]):
    root: Any


class InvalidKMSArn(RootModel[Any]):
    root: Any


class InvalidKeySigningKeyName(RootModel[Any]):
    root: Any


class InvalidKeySigningKeyStatus(RootModel[Any]):
    root: Any


class InvalidPaginationToken(RootModel[Any]):
    root: Any


class InvalidSigningStatus(RootModel[Any]):
    root: Any


class InvalidTrafficPolicyDocument(RootModel[Any]):
    root: Any


class InvalidVPCId(RootModel[Any]):
    root: Any


class Inverted(RootModel[bool]):
    root: bool


class IsPrivateZone(RootModel[bool]):
    root: bool


class KeySigningKeyAlreadyExists(RootModel[Any]):
    root: Any


class KeySigningKeyInParentDSRecord(RootModel[Any]):
    root: Any


class KeySigningKeyInUse(RootModel[Any]):
    root: Any


class KeySigningKeyWithActiveStatusNotFound(RootModel[Any]):
    root: Any


class LastVPCAssociation(RootModel[Any]):
    root: Any


class LimitValue(RootModel[conint(ge=1)]):
    root: conint(ge=1)


class LimitsExceeded(RootModel[Any]):
    root: Any


class ListCidrBlocksRequest(BaseModel):
    pass


class ListCidrCollectionsRequest(BaseModel):
    pass


class ListCidrLocationsRequest(BaseModel):
    pass


class ListGeoLocationsRequest(BaseModel):
    pass


class ListHealthChecksRequest(BaseModel):
    pass


class ListHostedZonesByNameRequest(BaseModel):
    pass


class ListHostedZonesByVPCRequest(BaseModel):
    pass


class ListHostedZonesRequest(BaseModel):
    pass


class ListQueryLoggingConfigsRequest(BaseModel):
    pass


class ListResourceRecordSetsRequest(BaseModel):
    pass


class ListReusableDelegationSetsRequest(BaseModel):
    pass


class ListTagsForResourceRequest(BaseModel):
    pass


class ListTrafficPoliciesRequest(BaseModel):
    pass


class ListTrafficPolicyInstancesByHostedZoneRequest(BaseModel):
    pass


class ListTrafficPolicyInstancesByPolicyRequest(BaseModel):
    pass


class ListTrafficPolicyInstancesRequest(BaseModel):
    pass


class ListTrafficPolicyVersionsRequest(BaseModel):
    pass


class ListVPCAssociationAuthorizationsRequest(BaseModel):
    pass


class LocationSummary(BaseModel):
    LocationName: Optional[CidrLocationNameDefaultAllowed] = None


class MaxResults(RootModel[str]):
    root: str


class MeasureLatency(RootModel[bool]):
    root: bool


class Message(RootModel[constr(max_length=1024)]):
    root: constr(max_length=1024)


class MetricName(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class Nameserver(RootModel[constr(min_length=0, max_length=255)]):
    root: constr(min_length=0, max_length=255)


class Namespace(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class NoSuchChange(RootModel[Any]):
    root: Any


class NoSuchCidrCollectionException(RootModel[Any]):
    root: Any


class NoSuchCidrLocationException(RootModel[Any]):
    root: Any


class NoSuchCloudWatchLogsLogGroup(RootModel[Any]):
    root: Any


class NoSuchDelegationSet(RootModel[Any]):
    root: Any


class NoSuchGeoLocation(RootModel[Any]):
    root: Any


class NoSuchHealthCheck(RootModel[Any]):
    root: Any


class NoSuchHostedZone(RootModel[Any]):
    root: Any


class NoSuchKeySigningKey(RootModel[Any]):
    root: Any


class NoSuchQueryLoggingConfig(RootModel[Any]):
    root: Any


class NoSuchTrafficPolicy(RootModel[Any]):
    root: Any


class NoSuchTrafficPolicyInstance(RootModel[Any]):
    root: Any


class Nonce(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class NotAuthorizedException(RootModel[Any]):
    root: Any


class PageMarker(RootModel[constr(max_length=64)]):
    root: constr(max_length=64)


class PageMaxItems(RootModel[str]):
    root: str


class PageTruncated(RootModel[bool]):
    root: bool


class PaginationToken(RootModel[constr(max_length=1024)]):
    root: constr(max_length=1024)


class Period(RootModel[conint(ge=60)]):
    root: conint(ge=60)


class Port(RootModel[conint(ge=1, le=65535)]):
    root: conint(ge=1, le=65535)


class PriorRequestNotComplete(RootModel[Any]):
    root: Any


class PublicZoneVPCAssociation(RootModel[Any]):
    root: Any


class QueryLoggingConfigAlreadyExists(RootModel[Any]):
    root: Any


class QueryLoggingConfigId(RootModel[constr(min_length=1, max_length=36)]):
    root: constr(min_length=1, max_length=36)


class RData(RootModel[constr(max_length=4000)]):
    root: constr(max_length=4000)


class RRType(Enum):
    SOA = 'SOA'
    A = 'A'
    TXT = 'TXT'
    NS = 'NS'
    CNAME = 'CNAME'
    MX = 'MX'
    NAPTR = 'NAPTR'
    PTR = 'PTR'
    SRV = 'SRV'
    SPF = 'SPF'
    AAAA = 'AAAA'
    CAA = 'CAA'
    DS = 'DS'


class RecordDataEntry(RootModel[constr(min_length=0, max_length=512)]):
    root: constr(min_length=0, max_length=512) = Field(
        ...,
        description='<p>A value that Amazon Route 53 returned for this resource record set. A <code>RecordDataEntry</code> element is one of the following:</p> <ul> <li> <p>For non-alias resource record sets, a <code>RecordDataEntry</code> element contains one value in the resource record set. If the resource record set contains multiple values, the response includes one <code>RecordDataEntry</code> element for each value.</p> </li> <li> <p>For multiple resource record sets that have the same name and type, which includes weighted, latency, geolocation, and failover, a <code>RecordDataEntry</code> element contains the value from the appropriate resource record set based on the request.</p> </li> <li> <p>For alias resource record sets that refer to Amazon Web Services resources other than another resource record set, the <code>RecordDataEntry</code> element contains an IP address or a domain name for the Amazon Web Services resource, depending on the type of resource.</p> </li> <li> <p>For alias resource record sets that refer to other resource record sets, a <code>RecordDataEntry</code> element contains one value from the referenced resource record set. If the referenced resource record set contains multiple values, the response includes one <code>RecordDataEntry</code> element for each value.</p> </li> </ul>',
    )


class RequestInterval(RootModel[conint(ge=10, le=30)]):
    root: conint(ge=10, le=30)


class ResettableElementName(Enum):
    FullyQualifiedDomainName = 'FullyQualifiedDomainName'
    Regions = 'Regions'
    ResourcePath = 'ResourcePath'
    ChildHealthChecks = 'ChildHealthChecks'


class ResettableElementNameList(RootModel[List[ResettableElementName]]):
    root: List[ResettableElementName] = Field(..., max_length=64)


class ResourceDescription(RootModel[constr(max_length=256)]):
    root: constr(max_length=256)


class ResourceId(RootModel[constr(max_length=32)]):
    root: constr(max_length=32)


class ResourcePath(RootModel[constr(max_length=255)]):
    root: constr(max_length=255)


class ResourceRecord(BaseModel):
    Value: RData


class ResourceRecordSetFailover(Enum):
    PRIMARY = 'PRIMARY'
    SECONDARY = 'SECONDARY'


class ResourceRecordSetIdentifier(RootModel[constr(min_length=1, max_length=128)]):
    root: constr(min_length=1, max_length=128)


class ResourceRecordSetMultiValueAnswer(RootModel[bool]):
    root: bool


class ResourceRecordSetRegion(Enum):
    us_east_1 = 'us-east-1'
    us_east_2 = 'us-east-2'
    us_west_1 = 'us-west-1'
    us_west_2 = 'us-west-2'
    ca_central_1 = 'ca-central-1'
    eu_west_1 = 'eu-west-1'
    eu_west_2 = 'eu-west-2'
    eu_west_3 = 'eu-west-3'
    eu_central_1 = 'eu-central-1'
    eu_central_2 = 'eu-central-2'
    ap_southeast_1 = 'ap-southeast-1'
    ap_southeast_2 = 'ap-southeast-2'
    ap_southeast_3 = 'ap-southeast-3'
    ap_northeast_1 = 'ap-northeast-1'
    ap_northeast_2 = 'ap-northeast-2'
    ap_northeast_3 = 'ap-northeast-3'
    eu_north_1 = 'eu-north-1'
    sa_east_1 = 'sa-east-1'
    cn_north_1 = 'cn-north-1'
    cn_northwest_1 = 'cn-northwest-1'
    ap_east_1 = 'ap-east-1'
    me_south_1 = 'me-south-1'
    me_central_1 = 'me-central-1'
    ap_south_1 = 'ap-south-1'
    ap_south_2 = 'ap-south-2'
    af_south_1 = 'af-south-1'
    eu_south_1 = 'eu-south-1'
    eu_south_2 = 'eu-south-2'
    ap_southeast_4 = 'ap-southeast-4'


class ResourceRecordSetWeight(RootModel[conint(ge=0, le=255)]):
    root: conint(ge=0, le=255)


class ResourceRecords(RootModel[List[ResourceRecord]]):
    root: List[ResourceRecord] = Field(..., min_length=1)


class ResourceURI(RootModel[constr(max_length=1024)]):
    root: constr(max_length=1024)


class ReusableDelegationSetLimitType(Enum):
    MAX_ZONES_BY_REUSABLE_DELEGATION_SET = 'MAX_ZONES_BY_REUSABLE_DELEGATION_SET'


class RoutingControlArn(RootModel[constr(min_length=1, max_length=255)]):
    root: constr(min_length=1, max_length=255)


class SearchString(RootModel[constr(max_length=255)]):
    root: constr(max_length=255)


class ServeSignature(RootModel[constr(min_length=1, max_length=1024)]):
    root: constr(min_length=1, max_length=1024)


class ServicePrincipal(RootModel[constr(max_length=128)]):
    root: constr(max_length=128)


class SigningKeyInteger(RootModel[int]):
    root: int


class SigningKeyName(RootModel[constr(min_length=3, max_length=128)]):
    root: constr(min_length=3, max_length=128)


class SigningKeyStatus(RootModel[constr(min_length=5, max_length=150)]):
    root: constr(min_length=5, max_length=150)


class SigningKeyStatusMessage(RootModel[constr(min_length=0, max_length=512)]):
    root: constr(min_length=0, max_length=512)


class SigningKeyString(RootModel[str]):
    root: str


class SigningKeyTag(RootModel[conint(ge=0, le=65536)]):
    root: conint(ge=0, le=65536)


class Statistic(Enum):
    Average = 'Average'
    Sum = 'Sum'
    SampleCount = 'SampleCount'
    Maximum = 'Maximum'
    Minimum = 'Minimum'


class Status(RootModel[str]):
    root: str


class SubnetMask(RootModel[constr(min_length=0, max_length=3)]):
    root: constr(min_length=0, max_length=3)


class TTL(RootModel[conint(ge=0, le=2147483647)]):
    root: conint(ge=0, le=2147483647)


class TagKey(RootModel[constr(max_length=128)]):
    root: constr(max_length=128)


class TagKeyList(RootModel[List[TagKey]]):
    root: List[TagKey] = Field(..., max_length=10, min_length=1)


class TagResourceId(RootModel[constr(max_length=64)]):
    root: constr(max_length=64)


class TagResourceIdList(RootModel[List[TagResourceId]]):
    root: List[TagResourceId] = Field(..., max_length=10, min_length=1)


class TagResourceType(Enum):
    healthcheck = 'healthcheck'
    hostedzone = 'hostedzone'


class TagValue(RootModel[constr(max_length=256)]):
    root: constr(max_length=256)


class TestDNSAnswerRequest(BaseModel):
    pass


class Threshold(RootModel[float]):
    root: float


class ThrottlingException(RootModel[Any]):
    root: Any


class TimeStamp(RootModel[datetime]):
    root: datetime


class TooManyHealthChecks(RootModel[Any]):
    root: Any


class TooManyHostedZones(RootModel[Any]):
    root: Any


class TooManyKeySigningKeys(RootModel[Any]):
    root: Any


class TooManyTrafficPolicies(RootModel[Any]):
    root: Any


class TooManyTrafficPolicyInstances(RootModel[Any]):
    root: Any


class TooManyTrafficPolicyVersionsForCurrentPolicy(RootModel[Any]):
    root: Any


class TooManyVPCAssociationAuthorizations(RootModel[Any]):
    root: Any


class TrafficPolicyAlreadyExists(RootModel[Any]):
    root: Any


class TrafficPolicyComment(RootModel[constr(max_length=1024)]):
    root: constr(max_length=1024)


class TrafficPolicyDocument(RootModel[constr(max_length=102400)]):
    root: constr(max_length=102400)


class TrafficPolicyId(RootModel[constr(min_length=1, max_length=36)]):
    root: constr(min_length=1, max_length=36)


class TrafficPolicyInUse(RootModel[Any]):
    root: Any


class TrafficPolicyInstanceAlreadyExists(RootModel[Any]):
    root: Any


class TrafficPolicyInstanceCount(RootModel[int]):
    root: int


class TrafficPolicyInstanceId(RootModel[constr(min_length=1, max_length=36)]):
    root: constr(min_length=1, max_length=36)


class TrafficPolicyInstanceState(RootModel[str]):
    root: str


class TrafficPolicyName(RootModel[constr(max_length=512)]):
    root: constr(max_length=512)


class TrafficPolicyVersion(RootModel[conint(ge=1, le=1000)]):
    root: conint(ge=1, le=1000)


class TrafficPolicyVersionMarker(RootModel[constr(max_length=4)]):
    root: constr(max_length=4)


class TransportProtocol(RootModel[str]):
    root: str


class UUID(RootModel[constr(pattern=r'[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}')]):
    root: constr(pattern=r'[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}')


class UpdateHostedZoneCommentRequest(BaseModel):
    Comment: Optional[ResourceDescription] = None


class UpdateTrafficPolicyCommentRequest(BaseModel):
    Comment: TrafficPolicyComment


class UpdateTrafficPolicyInstanceRequest(BaseModel):
    TTL_1: TTL = Field(..., alias='TTL')
    TrafficPolicyId_1: TrafficPolicyId = Field(..., alias='TrafficPolicyId')
    TrafficPolicyVersion_1: TrafficPolicyVersion = Field(
        ..., alias='TrafficPolicyVersion'
    )


class UsageCount(RootModel[conint(ge=0)]):
    root: conint(ge=0)


class VPCAssociationAuthorizationNotFound(RootModel[Any]):
    root: Any


class VPCAssociationNotFound(RootModel[Any]):
    root: Any


class VPCId(RootModel[constr(max_length=1024)]):
    root: constr(max_length=1024) = Field(
        ..., description='(Private hosted zones only) The ID of an Amazon VPC. '
    )


class VPCRegion(Enum):
    us_east_1 = 'us-east-1'
    us_east_2 = 'us-east-2'
    us_west_1 = 'us-west-1'
    us_west_2 = 'us-west-2'
    eu_west_1 = 'eu-west-1'
    eu_west_2 = 'eu-west-2'
    eu_west_3 = 'eu-west-3'
    eu_central_1 = 'eu-central-1'
    eu_central_2 = 'eu-central-2'
    ap_east_1 = 'ap-east-1'
    me_south_1 = 'me-south-1'
    us_gov_west_1 = 'us-gov-west-1'
    us_gov_east_1 = 'us-gov-east-1'
    us_iso_east_1 = 'us-iso-east-1'
    us_iso_west_1 = 'us-iso-west-1'
    us_isob_east_1 = 'us-isob-east-1'
    me_central_1 = 'me-central-1'
    ap_southeast_1 = 'ap-southeast-1'
    ap_southeast_2 = 'ap-southeast-2'
    ap_southeast_3 = 'ap-southeast-3'
    ap_south_1 = 'ap-south-1'
    ap_south_2 = 'ap-south-2'
    ap_northeast_1 = 'ap-northeast-1'
    ap_northeast_2 = 'ap-northeast-2'
    ap_northeast_3 = 'ap-northeast-3'
    eu_north_1 = 'eu-north-1'
    sa_east_1 = 'sa-east-1'
    ca_central_1 = 'ca-central-1'
    cn_north_1 = 'cn-north-1'
    af_south_1 = 'af-south-1'
    eu_south_1 = 'eu-south-1'
    eu_south_2 = 'eu-south-2'
    ap_southeast_4 = 'ap-southeast-4'


class Type(Enum):
    MAX_HEALTH_CHECKS_BY_OWNER = 'MAX_HEALTH_CHECKS_BY_OWNER'
    MAX_HOSTED_ZONES_BY_OWNER = 'MAX_HOSTED_ZONES_BY_OWNER'
    MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER = 'MAX_TRAFFIC_POLICY_INSTANCES_BY_OWNER'
    MAX_REUSABLE_DELEGATION_SETS_BY_OWNER = 'MAX_REUSABLE_DELEGATION_SETS_BY_OWNER'
    MAX_TRAFFIC_POLICIES_BY_OWNER = 'MAX_TRAFFIC_POLICIES_BY_OWNER'


class Field20130401CidrcollectionPostRequest(BaseModel):
    CallerReference: constr(pattern=r'\p{ASCII}+', min_length=1, max_length=64) = Field(
        ...,
        description='A client-specific token that allows requests to be securely retried so that the intended outcome will only occur once, retries receive a similar response, and there are no additional edge cases to handle.',
    )
    Name: constr(pattern=r'[0-9A-Za-z_\-]+', min_length=1, max_length=64) = Field(
        ...,
        description='A unique identifier for the account that can be used to reference the collection from other API calls.',
    )


class Field20130401DelegationsetPostRequest(BaseModel):
    CallerReference: constr(min_length=1, max_length=128) = Field(
        ...,
        description='A unique string that identifies the request, and that allows you to retry failed <code>CreateReusableDelegationSet</code> requests without the risk of executing the operation twice. You must use a unique <code>CallerReference</code> string every time you submit a <code>CreateReusableDelegationSet</code> request. <code>CallerReference</code> can be any unique string, for example a date/time stamp.',
    )
    HostedZoneId: Optional[constr(max_length=32)] = Field(
        None,
        description='If you want to mark the delegation set for an existing hosted zone as reusable, the ID for that hosted zone.',
    )


class AlarmIdentifier1(BaseModel):
    Name: Optional[AlarmName] = None
    Region: Optional[CloudWatchRegion] = None


class Field20130401HealthcheckHealthCheckIdPostRequest(BaseModel):
    AlarmIdentifier: Optional[AlarmIdentifier1] = Field(
        None,
        description='A complex type that identifies the CloudWatch alarm that you want Amazon Route 53 health checkers to use to determine whether the specified health check is healthy.',
    )
    ChildHealthChecks: Optional[List[HealthCheckId]] = Field(
        None,
        description='A complex type that contains one <code>ChildHealthCheck</code> element for each health check that you want to associate with a <code>CALCULATED</code> health check.',
        max_length=256,
    )
    Disabled: Optional[bool] = Field(
        None,
        description='<p>Stops Route 53 from performing health checks. When you disable a health check, here\'s what happens:</p> <ul> <li> <p> <b>Health checks that check the health of endpoints:</b> Route 53 stops submitting requests to your application, server, or other resource.</p> </li> <li> <p> <b>Calculated health checks:</b> Route 53 stops aggregating the status of the referenced health checks.</p> </li> <li> <p> <b>Health checks that monitor CloudWatch alarms:</b> Route 53 stops monitoring the corresponding CloudWatch metrics.</p> </li> </ul> <p>After you disable a health check, Route 53 considers the status of the health check to always be healthy. If you configured DNS failover, Route 53 continues to route traffic to the corresponding resources. If you want to stop routing traffic to a resource, change the value of <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-Inverted">Inverted</a>. </p> <p>Charges for a health check still apply when the health check is disabled. For more information, see <a href="http://aws.amazon.com/route53/pricing/">Amazon Route 53 Pricing</a>.</p>',
    )
    EnableSNI: Optional[bool] = Field(
        None,
        description="<p>Specify whether you want Amazon Route 53 to send the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>client_hello</code> message during <code>TLS</code> negotiation. This allows the endpoint to respond to <code>HTTPS</code> health check requests with the applicable SSL/TLS certificate.</p> <p>Some endpoints require that HTTPS requests include the host name in the <code>client_hello</code> message. If you don't enable SNI, the status of the health check will be SSL alert <code>handshake_failure</code>. A health check can also have that status for other reasons. If SNI is enabled and you're still getting the error, check the SSL/TLS configuration on your endpoint and confirm that your certificate is valid.</p> <p>The SSL/TLS certificate on your endpoint includes a domain name in the <code>Common Name</code> field and possibly several more in the <code>Subject Alternative Names</code> field. One of the domain names in the certificate should match the value that you specify for <code>FullyQualifiedDomainName</code>. If the endpoint responds to the <code>client_hello</code> message with a certificate that does not include the domain name that you specified in <code>FullyQualifiedDomainName</code>, a health checker will retry the handshake. In the second attempt, the health checker will omit <code>FullyQualifiedDomainName</code> from the <code>client_hello</code> message.</p>",
    )
    FailureThreshold: Optional[conint(ge=1, le=10)] = Field(
        None,
        description='<p>The number of consecutive health checks that an endpoint must pass or fail for Amazon Route 53 to change the current status of the endpoint from unhealthy to healthy or vice versa. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/dns-failover-determining-health-of-endpoints.html">How Amazon Route 53 Determines Whether an Endpoint Is Healthy</a> in the <i>Amazon Route 53 Developer Guide</i>.</p> <p>If you don\'t specify a value for <code>FailureThreshold</code>, the default value is three health checks.</p>',
    )
    FullyQualifiedDomainName: Optional[constr(max_length=255)] = Field(
        None,
        description='<p>Amazon Route 53 behavior depends on whether you specify a value for <code>IPAddress</code>.</p> <note> <p>If a health check already has a value for <code>IPAddress</code>, you can change the value. However, you can\'t update an existing health check to add or remove the value of <code>IPAddress</code>. </p> </note> <p> <b>If you specify a value for</b> <code>IPAddress</code>:</p> <p>Route 53 sends health check requests to the specified IPv4 or IPv6 address and passes the value of <code>FullyQualifiedDomainName</code> in the <code>Host</code> header for all health checks except TCP health checks. This is typically the fully qualified DNS name of the endpoint on which you want Route 53 to perform health checks.</p> <p>When Route 53 checks the health of an endpoint, here is how it constructs the <code>Host</code> header:</p> <ul> <li> <p>If you specify a value of <code>80</code> for <code>Port</code> and <code>HTTP</code> or <code>HTTP_STR_MATCH</code> for <code>Type</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>Host</code> header.</p> </li> <li> <p>If you specify a value of <code>443</code> for <code>Port</code> and <code>HTTPS</code> or <code>HTTPS_STR_MATCH</code> for <code>Type</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> to the endpoint in the <code>Host</code> header.</p> </li> <li> <p>If you specify another value for <code>Port</code> and any value except <code>TCP</code> for <code>Type</code>, Route 53 passes <i> <code>FullyQualifiedDomainName</code>:<code>Port</code> </i> to the endpoint in the <code>Host</code> header.</p> </li> </ul> <p>If you don\'t specify a value for <code>FullyQualifiedDomainName</code>, Route 53 substitutes the value of <code>IPAddress</code> in the <code>Host</code> header in each of the above cases.</p> <p> <b>If you don\'t specify a value for</b> <code>IPAddress</code>:</p> <p>If you don\'t specify a value for <code>IPAddress</code>, Route 53 sends a DNS request to the domain that you specify in <code>FullyQualifiedDomainName</code> at the interval you specify in <code>RequestInterval</code>. Using an IPv4 address that is returned by DNS, Route 53 then checks the health of the endpoint.</p> <note> <p>If you don\'t specify a value for <code>IPAddress</code>, Route 53 uses only IPv4 to send health checks to the endpoint. If there\'s no resource record set with a type of A for the name that you specify for <code>FullyQualifiedDomainName</code>, the health check fails with a "DNS resolution failed" error.</p> </note> <p>If you want to check the health of weighted, latency, or failover resource record sets and you choose to specify the endpoint only by <code>FullyQualifiedDomainName</code>, we recommend that you create a separate health check for each endpoint. For example, create a health check for each HTTP server that is serving content for www.example.com. For the value of <code>FullyQualifiedDomainName</code>, specify the domain name of the server (such as <code>us-east-2-www.example.com</code>), not the name of the resource record sets (www.example.com).</p> <important> <p>In this configuration, if the value of <code>FullyQualifiedDomainName</code> matches the name of the resource record sets and you then associate the health check with those resource record sets, health check results will be unpredictable.</p> </important> <p>In addition, if the value of <code>Type</code> is <code>HTTP</code>, <code>HTTPS</code>, <code>HTTP_STR_MATCH</code>, or <code>HTTPS_STR_MATCH</code>, Route 53 passes the value of <code>FullyQualifiedDomainName</code> in the <code>Host</code> header, as it does when you specify a value for <code>IPAddress</code>. If the value of <code>Type</code> is <code>TCP</code>, Route 53 doesn\'t pass a <code>Host</code> header.</p>',
    )
    HealthCheckVersion: Optional[conint(ge=1)] = Field(
        None,
        description='<p>A sequential counter that Amazon Route 53 sets to <code>1</code> when you create a health check and increments by 1 each time you update settings for the health check.</p> <p>We recommend that you use <code>GetHealthCheck</code> or <code>ListHealthChecks</code> to get the current value of <code>HealthCheckVersion</code> for the health check that you want to update, and that you include that value in your <code>UpdateHealthCheck</code> request. This prevents Route 53 from overwriting an intervening update:</p> <ul> <li> <p>If the value in the <code>UpdateHealthCheck</code> request matches the value of <code>HealthCheckVersion</code> in the health check, Route 53 updates the health check with the new settings.</p> </li> <li> <p>If the value of <code>HealthCheckVersion</code> in the health check is greater, the health check was changed after you got the version number. Route 53 does not update the health check, and it returns a <code>HealthCheckVersionMismatch</code> error.</p> </li> </ul>',
    )
    HealthThreshold: Optional[conint(ge=0, le=256)] = Field(
        None,
        description='<p>The number of child health checks that are associated with a <code>CALCULATED</code> health that Amazon Route 53 must consider healthy for the <code>CALCULATED</code> health check to be considered healthy. To specify the child health checks that you want to associate with a <code>CALCULATED</code> health check, use the <code>ChildHealthChecks</code> and <code>ChildHealthCheck</code> elements.</p> <p>Note the following:</p> <ul> <li> <p>If you specify a number greater than the number of child health checks, Route 53 always considers this health check to be unhealthy.</p> </li> <li> <p>If you specify <code>0</code>, Route 53 always considers this health check to be healthy.</p> </li> </ul>',
    )
    IPAddress: Optional[
        constr(
            pattern=r'(^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$|^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$)',
            max_length=45,
        )
    ] = Field(
        None,
        description='<p>The IPv4 or IPv6 IP address for the endpoint that you want Amazon Route 53 to perform health checks on. If you don\'t specify a value for <code>IPAddress</code>, Route 53 sends a DNS request to resolve the domain name that you specify in <code>FullyQualifiedDomainName</code> at the interval that you specify in <code>RequestInterval</code>. Using an IP address that is returned by DNS, Route 53 then checks the health of the endpoint.</p> <p>Use one of the following formats for the value of <code>IPAddress</code>: </p> <ul> <li> <p> <b>IPv4 address</b>: four values between 0 and 255, separated by periods (.), for example, <code>192.0.2.44</code>.</p> </li> <li> <p> <b>IPv6 address</b>: eight groups of four hexadecimal values, separated by colons (:), for example, <code>2001:0db8:85a3:0000:0000:abcd:0001:2345</code>. You can also shorten IPv6 addresses as described in RFC 5952, for example, <code>2001:db8:85a3::abcd:1:2345</code>.</p> </li> </ul> <p>If the endpoint is an EC2 instance, we recommend that you create an Elastic IP address, associate it with your EC2 instance, and specify the Elastic IP address for <code>IPAddress</code>. This ensures that the IP address of your instance never changes. For more information, see the applicable documentation:</p> <ul> <li> <p>Linux: <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/elastic-ip-addresses-eip.html">Elastic IP Addresses (EIP)</a> in the <i>Amazon EC2 User Guide for Linux Instances</i> </p> </li> <li> <p>Windows: <a href="https://docs.aws.amazon.com/AWSEC2/latest/WindowsGuide/elastic-ip-addresses-eip.html">Elastic IP Addresses (EIP)</a> in the <i>Amazon EC2 User Guide for Windows Instances</i> </p> </li> </ul> <note> <p>If a health check already has a value for <code>IPAddress</code>, you can change the value. However, you can\'t update an existing health check to add or remove the value of <code>IPAddress</code>. </p> </note> <p>For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName">FullyQualifiedDomainName</a>. </p> <p>Constraints: Route 53 can\'t check the health of endpoints for which the IP address is in local, private, non-routable, or multicast ranges. For more information about IP addresses for which you can\'t create health checks, see the following documents:</p> <ul> <li> <p> <a href="https://tools.ietf.org/html/rfc5735">RFC 5735, Special Use IPv4 Addresses</a> </p> </li> <li> <p> <a href="https://tools.ietf.org/html/rfc6598">RFC 6598, IANA-Reserved IPv4 Prefix for Shared Address Space</a> </p> </li> <li> <p> <a href="https://tools.ietf.org/html/rfc5156">RFC 5156, Special-Use IPv6 Addresses</a> </p> </li> </ul>',
    )
    InsufficientDataHealthStatus_1: Optional[InsufficientDataHealthStatus] = Field(
        None,
        alias='InsufficientDataHealthStatus',
        description='<p>When CloudWatch has insufficient data about the metric to determine the alarm state, the status that you want Amazon Route 53 to assign to the health check:</p> <ul> <li> <p> <code>Healthy</code>: Route 53 considers the health check to be healthy.</p> </li> <li> <p> <code>Unhealthy</code>: Route 53 considers the health check to be unhealthy.</p> </li> <li> <p> <code>LastKnownStatus</code>: By default, Route 53 uses the status of the health check from the last time CloudWatch had sufficient data to determine the alarm state. For new health checks that have no last known status, the status for the health check is healthy.</p> </li> </ul>',
    )
    Inverted: Optional[bool] = Field(
        None,
        description='Specify whether you want Amazon Route 53 to invert the status of a health check, for example, to consider a health check unhealthy when it otherwise would be considered healthy.',
    )
    Port: Optional[conint(ge=1, le=65535)] = Field(
        None,
        description="<p>The port on the endpoint that you want Amazon Route 53 to perform health checks on.</p> <note> <p>Don't specify a value for <code>Port</code> when you specify a value for <code>Type</code> of <code>CLOUDWATCH_METRIC</code> or <code>CALCULATED</code>.</p> </note>",
    )
    Regions: Optional[List[HealthCheckRegion]] = Field(
        None,
        description='A complex type that contains one <code>Region</code> element for each region that you want Amazon Route 53 health checkers to check the specified endpoint from.',
        max_length=64,
        min_length=3,
    )
    ResetElements: Optional[List[ResettableElementName]] = Field(
        None,
        description='<p>A complex type that contains one <code>ResettableElementName</code> element for each element that you want to reset to the default value. Valid values for <code>ResettableElementName</code> include the following:</p> <ul> <li> <p> <code>ChildHealthChecks</code>: Amazon Route 53 resets <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ChildHealthChecks">ChildHealthChecks</a> to null.</p> </li> <li> <p> <code>FullyQualifiedDomainName</code>: Route 53 resets <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_UpdateHealthCheck.html#Route53-UpdateHealthCheck-request-FullyQualifiedDomainName">FullyQualifiedDomainName</a>. to null.</p> </li> <li> <p> <code>Regions</code>: Route 53 resets the <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-Regions">Regions</a> list to the default set of regions. </p> </li> <li> <p> <code>ResourcePath</code>: Route 53 resets <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_HealthCheckConfig.html#Route53-Type-HealthCheckConfig-ResourcePath">ResourcePath</a> to null.</p> </li> </ul>',
        max_length=64,
    )
    ResourcePath: Optional[constr(max_length=255)] = Field(
        None,
        description='<p>The path that you want Amazon Route 53 to request when performing health checks. The path can be any value for which your endpoint will return an HTTP status code of 2xx or 3xx when the endpoint is healthy, for example the file /docs/route53-health-check.html. You can also include query string parameters, for example, <code>/welcome.html?language=jp&amp;login=y</code>. </p> <p>Specify this value only if you want to change it.</p>',
    )
    SearchString: Optional[constr(max_length=255)] = Field(
        None,
        description="If the value of <code>Type</code> is <code>HTTP_STR_MATCH</code> or <code>HTTPS_STR_MATCH</code>, the string that you want Amazon Route 53 to search for in the response body from the specified resource. If the string appears in the response body, Route 53 considers the resource healthy. (You can't change the value of <code>Type</code> when you update a health check.)",
    )


class HostedZoneConfig(BaseModel):
    Comment: Optional[ResourceDescription] = None
    PrivateZone: Optional[IsPrivateZone] = None


class VPC(BaseModel):
    VPCId_1: Optional[VPCId] = Field(None, alias='VPCId')
    VPCRegion_1: Optional[VPCRegion] = Field(None, alias='VPCRegion')


class Field20130401HostedzonePostRequest(BaseModel):
    CallerReference: constr(min_length=1, max_length=128) = Field(
        ...,
        description='A unique string that identifies the request and that allows failed <code>CreateHostedZone</code> requests to be retried without the risk of executing the operation twice. You must use a unique <code>CallerReference</code> string every time you submit a <code>CreateHostedZone</code> request. <code>CallerReference</code> can be any unique string, for example, a date/time stamp.',
    )
    DelegationSetId: Optional[constr(max_length=32)] = Field(
        None,
        description='If you want to associate a reusable delegation set with this hosted zone, the ID that Amazon Route\xa053 assigned to the reusable delegation set when you created it. For more information about reusable delegation sets, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateReusableDelegationSet.html">CreateReusableDelegationSet</a>.',
    )
    HostedZoneConfig_1: Optional[HostedZoneConfig] = Field(
        None,
        alias='HostedZoneConfig',
        description="A complex type that contains an optional comment about your hosted zone. If you don't want to specify a comment, omit both the <code>HostedZoneConfig</code> and <code>Comment</code> elements.",
    )
    Name: constr(max_length=1024) = Field(
        ...,
        description="<p>The name of the domain. Specify a fully qualified domain name, for example, <i>www.example.com</i>. The trailing dot is optional; Amazon Route\xa053 assumes that the domain name is fully qualified. This means that Route\xa053 treats <i>www.example.com</i> (without a trailing dot) and <i>www.example.com.</i> (with a trailing dot) as identical.</p> <p>If you're creating a public hosted zone, this is the name you have registered with your DNS registrar. If your domain name is registered with a registrar other than Route\xa053, change the name servers for your domain to the set of <code>NameServers</code> that <code>CreateHostedZone</code> returns in <code>DelegationSet</code>.</p>",
    )
    VPC_1: Optional[VPC] = Field(
        None,
        alias='VPC',
        description='<p>(Private hosted zones only) A complex type that contains information about an Amazon VPC.</p> <p>If you associate a private hosted zone with an Amazon VPC when you make a <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateHostedZone.html">CreateHostedZone</a> request, the following parameters are also required.</p>',
    )


class Field20130401HostedzoneIdPostRequest(BaseModel):
    Comment: Optional[constr(max_length=256)] = Field(
        None,
        description="The new comment for the hosted zone. If you don't specify a value for <code>Comment</code>, Amazon Route 53 deletes the existing value of the <code>Comment</code> element, if any.",
    )


class Field20130401HostedzoneIdAssociatevpcPostRequest(BaseModel):
    Comment: Optional[str] = Field(
        None, description=' <i>Optional:</i> A comment about the association request.'
    )
    VPC_1: VPC = Field(
        ...,
        alias='VPC',
        description='<p>(Private hosted zones only) A complex type that contains information about an Amazon VPC.</p> <p>If you associate a private hosted zone with an Amazon VPC when you make a <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateHostedZone.html">CreateHostedZone</a> request, the following parameters are also required.</p>',
    )


class Field20130401HostedzoneIdAuthorizevpcassociationPostRequest(BaseModel):
    VPC_1: VPC = Field(
        ...,
        alias='VPC',
        description='<p>(Private hosted zones only) A complex type that contains information about an Amazon VPC.</p> <p>If you associate a private hosted zone with an Amazon VPC when you make a <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateHostedZone.html">CreateHostedZone</a> request, the following parameters are also required.</p>',
    )


class Field20130401HostedzoneIdDeauthorizevpcassociationPostRequest(BaseModel):
    VPC_1: VPC = Field(
        ...,
        alias='VPC',
        description='<p>(Private hosted zones only) A complex type that contains information about an Amazon VPC.</p> <p>If you associate a private hosted zone with an Amazon VPC when you make a <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateHostedZone.html">CreateHostedZone</a> request, the following parameters are also required.</p>',
    )


class Field20130401HostedzoneIdDisassociatevpcPostRequest(BaseModel):
    Comment: Optional[str] = Field(
        None,
        description=' <i>Optional:</i> A comment about the disassociation request.',
    )
    VPC_1: VPC = Field(
        ...,
        alias='VPC',
        description='<p>(Private hosted zones only) A complex type that contains information about an Amazon VPC.</p> <p>If you associate a private hosted zone with an Amazon VPC when you make a <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateHostedZone.html">CreateHostedZone</a> request, the following parameters are also required.</p>',
    )


class Type1(Enum):
    SOA = 'SOA'
    A = 'A'
    TXT = 'TXT'
    NS = 'NS'
    CNAME = 'CNAME'
    MX = 'MX'
    NAPTR = 'NAPTR'
    PTR = 'PTR'
    SRV = 'SRV'
    SPF = 'SPF'
    AAAA = 'AAAA'
    CAA = 'CAA'
    DS = 'DS'


class Type3(Enum):
    MAX_RRSETS_BY_ZONE = 'MAX_RRSETS_BY_ZONE'
    MAX_VPCS_ASSOCIATED_BY_ZONE = 'MAX_VPCS_ASSOCIATED_BY_ZONE'


class Vpcregion(Enum):
    us_east_1 = 'us-east-1'
    us_east_2 = 'us-east-2'
    us_west_1 = 'us-west-1'
    us_west_2 = 'us-west-2'
    eu_west_1 = 'eu-west-1'
    eu_west_2 = 'eu-west-2'
    eu_west_3 = 'eu-west-3'
    eu_central_1 = 'eu-central-1'
    eu_central_2 = 'eu-central-2'
    ap_east_1 = 'ap-east-1'
    me_south_1 = 'me-south-1'
    us_gov_west_1 = 'us-gov-west-1'
    us_gov_east_1 = 'us-gov-east-1'
    us_iso_east_1 = 'us-iso-east-1'
    us_iso_west_1 = 'us-iso-west-1'
    us_isob_east_1 = 'us-isob-east-1'
    me_central_1 = 'me-central-1'
    ap_southeast_1 = 'ap-southeast-1'
    ap_southeast_2 = 'ap-southeast-2'
    ap_southeast_3 = 'ap-southeast-3'
    ap_south_1 = 'ap-south-1'
    ap_south_2 = 'ap-south-2'
    ap_northeast_1 = 'ap-northeast-1'
    ap_northeast_2 = 'ap-northeast-2'
    ap_northeast_3 = 'ap-northeast-3'
    eu_north_1 = 'eu-north-1'
    sa_east_1 = 'sa-east-1'
    ca_central_1 = 'ca-central-1'
    cn_north_1 = 'cn-north-1'
    af_south_1 = 'af-south-1'
    eu_south_1 = 'eu-south-1'
    eu_south_2 = 'eu-south-2'
    ap_southeast_4 = 'ap-southeast-4'


class Field20130401KeysigningkeyPostRequest(BaseModel):
    CallerReference: constr(min_length=1, max_length=128) = Field(
        ..., description='A unique string that identifies the request.'
    )
    HostedZoneId: constr(max_length=32) = Field(
        ..., description='The unique string (ID) used to identify a hosted zone.'
    )
    KeyManagementServiceArn: str = Field(
        ...,
        description='<p>The Amazon resource name (ARN) for a customer managed key in Key Management Service (KMS). The <code>KeyManagementServiceArn</code> must be unique for each key-signing key (KSK) in a single hosted zone. To see an example of <code>KeyManagementServiceArn</code> that grants the correct permissions for DNSSEC, scroll down to <b>Example</b>. </p> <p>You must configure the customer managed customer managed key as follows:</p> <dl> <dt>Status</dt> <dd> <p>Enabled</p> </dd> <dt>Key spec</dt> <dd> <p>ECC_NIST_P256</p> </dd> <dt>Key usage</dt> <dd> <p>Sign and verify</p> </dd> <dt>Key policy</dt> <dd> <p>The key policy must give permission for the following actions:</p> <ul> <li> <p>DescribeKey</p> </li> <li> <p>GetPublicKey</p> </li> <li> <p>Sign</p> </li> </ul> <p>The key policy must also include the Amazon Route 53 service in the principal for your account. Specify the following:</p> <ul> <li> <p> <code>"Service": "dnssec-route53.amazonaws.com"</code> </p> </li> </ul> </dd> </dl> <p>For more information about working with a customer managed key in KMS, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html">Key Management Service concepts</a>.</p>',
    )
    Name: constr(min_length=3, max_length=128) = Field(
        ...,
        description='A string used to identify a key-signing key (KSK). <code>Name</code> can include numbers, letters, and underscores (_). <code>Name</code> must be unique for each key-signing key in the same hosted zone.',
    )
    Status: constr(min_length=5, max_length=150) = Field(
        ...,
        description='A string specifying the initial status of the key-signing key (KSK). You can set the value to <code>ACTIVE</code> or <code>INACTIVE</code>.',
    )


class Field20130401QueryloggingconfigPostRequest(BaseModel):
    CloudWatchLogsLogGroupArn: str = Field(
        ...,
        description='<p>The Amazon Resource Name (ARN) for the log group that you want to Amazon Route 53 to send query logs to. This is the format of the ARN:</p> <p>arn:aws:logs:<i>region</i>:<i>account-id</i>:log-group:<i>log_group_name</i> </p> <p>To get the ARN for a log group, you can use the CloudWatch console, the <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeLogGroups.html">DescribeLogGroups</a> API action, the <a href="https://docs.aws.amazon.com/cli/latest/reference/logs/describe-log-groups.html">describe-log-groups</a> command, or the applicable command in one of the Amazon Web Services SDKs.</p>',
    )
    HostedZoneId: constr(max_length=32) = Field(
        ...,
        description='The ID of the hosted zone that you want to log queries for. You can log queries only for public hosted zones.',
    )


class Type4(Enum):
    MAX_ZONES_BY_REUSABLE_DELEGATION_SET = 'MAX_ZONES_BY_REUSABLE_DELEGATION_SET'


class Field20130401TagsResourceTypePostRequest(BaseModel):
    ResourceIds: List[TagResourceId] = Field(
        ...,
        description='A complex type that contains the ResourceId element for each resource for which you want to get a list of tags.',
        max_length=10,
        min_length=1,
    )


class ResourceType(Enum):
    healthcheck = 'healthcheck'
    hostedzone = 'hostedzone'


class Recordtype(Enum):
    SOA = 'SOA'
    A = 'A'
    TXT = 'TXT'
    NS = 'NS'
    CNAME = 'CNAME'
    MX = 'MX'
    NAPTR = 'NAPTR'
    PTR = 'PTR'
    SRV = 'SRV'
    SPF = 'SPF'
    AAAA = 'AAAA'
    CAA = 'CAA'
    DS = 'DS'


class Field20130401TrafficpolicyPostRequest(BaseModel):
    Comment: Optional[constr(max_length=1024)] = Field(
        None,
        description='(Optional) Any comments that you want to include about the traffic policy.',
    )
    Document: constr(max_length=102400) = Field(
        ...,
        description='The definition of this traffic policy in JSON format. For more information, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/api-policies-traffic-policy-document-format.html">Traffic Policy Document Format</a>.',
    )
    Name: constr(max_length=512) = Field(
        ..., description='The name of the traffic policy.'
    )


class Field20130401TrafficpolicyIdPostRequest(BaseModel):
    Comment: Optional[constr(max_length=1024)] = Field(
        None,
        description='The comment that you specified in the <code>CreateTrafficPolicyVersion</code> request, if any.',
    )
    Document: constr(max_length=102400) = Field(
        ...,
        description='The definition of this version of the traffic policy, in JSON format. You specified the JSON in the <code>CreateTrafficPolicyVersion</code> request. For more information about the JSON format, see <a href="https://docs.aws.amazon.com/Route53/latest/APIReference/API_CreateTrafficPolicy.html">CreateTrafficPolicy</a>.',
    )


class Field20130401TrafficpolicyIdVersionPostRequest(BaseModel):
    Comment: constr(max_length=1024) = Field(
        ..., description='The new comment for the specified traffic policy and version.'
    )


class Field20130401TrafficpolicyinstancePostRequest(BaseModel):
    HostedZoneId: constr(max_length=32) = Field(
        ...,
        description='The ID of the hosted zone that you want Amazon Route 53 to create resource record sets in by using the configuration in a traffic policy.',
    )
    Name: constr(max_length=1024) = Field(
        ...,
        description='The domain name (such as example.com) or subdomain name (such as www.example.com) for which Amazon Route 53 responds to DNS queries by using the resource record sets that Route 53 creates for this traffic policy instance.',
    )
    TTL: conint(ge=0, le=2147483647) = Field(
        ...,
        description='(Optional) The TTL that you want Amazon Route 53 to assign to all of the resource record sets that it creates in the specified hosted zone.',
    )
    TrafficPolicyId: constr(min_length=1, max_length=36) = Field(
        ...,
        description='The ID of the traffic policy that you want to use to create resource record sets in the specified hosted zone.',
    )
    TrafficPolicyVersion: conint(ge=1, le=1000) = Field(
        ...,
        description='The version of the traffic policy that you want to use to create resource record sets in the specified hosted zone.',
    )


class Field20130401TrafficpolicyinstanceIdPostRequest(BaseModel):
    TTL: conint(ge=0, le=2147483647) = Field(
        ...,
        description='The TTL that you want Amazon Route 53 to assign to all of the updated resource record sets.',
    )
    TrafficPolicyId: constr(min_length=1, max_length=36) = Field(
        ...,
        description='The ID of the traffic policy that you want Amazon Route 53 to use to update resource record sets for the specified traffic policy instance.',
    )
    TrafficPolicyVersion: conint(ge=1, le=1000) = Field(
        ...,
        description='The version of the traffic policy that you want Amazon Route 53 to use to update resource record sets for the specified traffic policy instance.',
    )


class Trafficpolicyinstancetype(Enum):
    SOA = 'SOA'
    A = 'A'
    TXT = 'TXT'
    NS = 'NS'
    CNAME = 'CNAME'
    MX = 'MX'
    NAPTR = 'NAPTR'
    PTR = 'PTR'
    SRV = 'SRV'
    SPF = 'SPF'
    AAAA = 'AAAA'
    CAA = 'CAA'
    DS = 'DS'


class AccountLimit(BaseModel):
    Type: AccountLimitType
    Value: LimitValue


class AlarmIdentifier(BaseModel):
    Name: AlarmName
    Region: CloudWatchRegion


class AliasTarget(BaseModel):
    DNSName_1: DNSName = Field(..., alias='DNSName')
    EvaluateTargetHealth: AliasHealthEnabled
    HostedZoneId: ResourceId


class ChangeCidrCollectionResponse(BaseModel):
    Id: ChangeId


class ChangeInfo(BaseModel):
    Comment: Optional[ResourceDescription] = None
    Id: ResourceId
    Status: ChangeStatus
    SubmittedAt: TimeStamp


class ChangeResourceRecordSetsResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class CheckerIpRanges(RootModel[List[IPAddressCidr]]):
    root: List[IPAddressCidr]


class ChildHealthCheckList(RootModel[List[HealthCheckId]]):
    root: List[HealthCheckId] = Field(..., max_length=256)


class CidrBlockSummary(BaseModel):
    CidrBlock: Optional[Cidr] = None
    LocationName: Optional[CidrLocationNameDefaultNotAllowed] = None


class CidrCollection(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[UUID] = None
    Name: Optional[CollectionName] = None
    Version: Optional[CollectionVersion] = None


class CidrCollectionChange(BaseModel):
    Action: CidrCollectionChangeAction
    CidrList_1: CidrList = Field(..., alias='CidrList')
    LocationName: CidrLocationNameDefaultNotAllowed


class CidrCollectionChanges(RootModel[List[CidrCollectionChange]]):
    root: List[CidrCollectionChange] = Field(..., max_length=1000, min_length=1)


class CidrRoutingConfig(BaseModel):
    CollectionId: UUID
    LocationName: CidrLocationNameDefaultAllowed


class CollectionSummary(BaseModel):
    Arn: Optional[ARN] = None
    Id: Optional[UUID] = None
    Name: Optional[CollectionName] = None
    Version: Optional[CollectionVersion] = None


class CreateCidrCollectionResponse(BaseModel):
    Collection: Optional[CidrCollection] = None


class CreateKeySigningKeyRequest(BaseModel):
    CallerReference: Nonce
    HostedZoneId: ResourceId
    KeyManagementServiceArn: SigningKeyString
    Name: SigningKeyName
    Status: SigningKeyStatus


class CreateQueryLoggingConfigRequest(BaseModel):
    CloudWatchLogsLogGroupArn_1: CloudWatchLogsLogGroupArn = Field(
        ..., alias='CloudWatchLogsLogGroupArn'
    )
    HostedZoneId: ResourceId


class CreateReusableDelegationSetRequest(BaseModel):
    CallerReference: Nonce
    HostedZoneId: Optional[ResourceId] = None


class CreateTrafficPolicyInstanceRequest(BaseModel):
    HostedZoneId: ResourceId
    Name: DNSName
    TTL_1: TTL = Field(..., alias='TTL')
    TrafficPolicyId_1: TrafficPolicyId = Field(..., alias='TrafficPolicyId')
    TrafficPolicyVersion_1: TrafficPolicyVersion = Field(
        ..., alias='TrafficPolicyVersion'
    )


class CreateTrafficPolicyRequest(BaseModel):
    Comment: Optional[TrafficPolicyComment] = None
    Document: TrafficPolicyDocument
    Name: TrafficPolicyName


class CreateTrafficPolicyVersionRequest(BaseModel):
    Comment: Optional[TrafficPolicyComment] = None
    Document: TrafficPolicyDocument


class DNSSECStatus(BaseModel):
    ServeSignature_1: Optional[ServeSignature] = Field(None, alias='ServeSignature')
    StatusMessage: Optional[SigningKeyStatusMessage] = None


class DeactivateKeySigningKeyResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class DelegationSet(BaseModel):
    CallerReference: Optional[Nonce] = None
    Id: Optional[ResourceId] = None
    NameServers: DelegationSetNameServers


class DelegationSets(RootModel[List[DelegationSet]]):
    root: List[DelegationSet]


class DeleteHostedZoneResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class DeleteKeySigningKeyResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class Dimension(BaseModel):
    Name: DimensionField
    Value: DimensionField


class DimensionList(RootModel[List[Dimension]]):
    root: List[Dimension] = Field(..., max_length=10)


class DisableHostedZoneDNSSECResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class DisassociateVPCFromHostedZoneResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class EnableHostedZoneDNSSECResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class GeoLocation(BaseModel):
    ContinentCode: Optional[GeoLocationContinentCode] = None
    CountryCode: Optional[GeoLocationCountryCode] = None
    SubdivisionCode: Optional[GeoLocationSubdivisionCode] = None


class GeoLocationDetails(BaseModel):
    ContinentCode: Optional[GeoLocationContinentCode] = None
    ContinentName: Optional[GeoLocationContinentName] = None
    CountryCode: Optional[GeoLocationCountryCode] = None
    CountryName: Optional[GeoLocationCountryName] = None
    SubdivisionCode: Optional[GeoLocationSubdivisionCode] = None
    SubdivisionName: Optional[GeoLocationSubdivisionName] = None


class GeoLocationDetailsList(RootModel[List[GeoLocationDetails]]):
    root: List[GeoLocationDetails]


class GetAccountLimitResponse(BaseModel):
    Count: UsageCount
    Limit: AccountLimit


class GetChangeResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class GetCheckerIpRangesResponse(BaseModel):
    CheckerIpRanges_1: CheckerIpRanges = Field(..., alias='CheckerIpRanges')


class GetGeoLocationResponse(BaseModel):
    GeoLocationDetails_1: GeoLocationDetails = Field(..., alias='GeoLocationDetails')


class GetHealthCheckCountResponse(BaseModel):
    HealthCheckCount_1: HealthCheckCount = Field(..., alias='HealthCheckCount')


class GetHostedZoneCountResponse(BaseModel):
    HostedZoneCount_1: HostedZoneCount = Field(..., alias='HostedZoneCount')


class GetReusableDelegationSetResponse(BaseModel):
    DelegationSet_1: DelegationSet = Field(..., alias='DelegationSet')


class GetTrafficPolicyInstanceCountResponse(BaseModel):
    TrafficPolicyInstanceCount_1: TrafficPolicyInstanceCount = Field(
        ..., alias='TrafficPolicyInstanceCount'
    )


class HealthCheckConfig(BaseModel):
    AlarmIdentifier_1: Optional[AlarmIdentifier] = Field(None, alias='AlarmIdentifier')
    ChildHealthChecks: Optional[ChildHealthCheckList] = None
    Disabled_1: Optional[Disabled] = Field(None, alias='Disabled')
    EnableSNI_1: Optional[EnableSNI] = Field(None, alias='EnableSNI')
    FailureThreshold_1: Optional[FailureThreshold] = Field(
        None, alias='FailureThreshold'
    )
    FullyQualifiedDomainName_1: Optional[FullyQualifiedDomainName] = Field(
        None, alias='FullyQualifiedDomainName'
    )
    HealthThreshold_1: Optional[HealthThreshold] = Field(None, alias='HealthThreshold')
    IPAddress_1: Optional[IPAddress] = Field(None, alias='IPAddress')
    InsufficientDataHealthStatus_1: Optional[InsufficientDataHealthStatus] = Field(
        None, alias='InsufficientDataHealthStatus'
    )
    Inverted_1: Optional[Inverted] = Field(None, alias='Inverted')
    MeasureLatency_1: Optional[MeasureLatency] = Field(None, alias='MeasureLatency')
    Port_1: Optional[Port] = Field(None, alias='Port')
    Regions: Optional[HealthCheckRegionList] = None
    RequestInterval_1: Optional[RequestInterval] = Field(None, alias='RequestInterval')
    ResourcePath_1: Optional[ResourcePath] = Field(None, alias='ResourcePath')
    RoutingControlArn_1: Optional[RoutingControlArn] = Field(
        None, alias='RoutingControlArn'
    )
    SearchString_1: Optional[SearchString] = Field(None, alias='SearchString')
    Type: HealthCheckType


class HostedZoneLimit(BaseModel):
    Type: HostedZoneLimitType
    Value: LimitValue


class HostedZoneOwner(BaseModel):
    OwningAccount: Optional[AWSAccountID] = None
    OwningService: Optional[HostedZoneOwningService] = None


class HostedZoneSummary(BaseModel):
    HostedZoneId: ResourceId
    Name: DNSName
    Owner: HostedZoneOwner


class KeySigningKey(BaseModel):
    CreatedDate: Optional[TimeStamp] = None
    DNSKEYRecord: Optional[SigningKeyString] = None
    DSRecord: Optional[SigningKeyString] = None
    DigestAlgorithmMnemonic: Optional[SigningKeyString] = None
    DigestAlgorithmType: Optional[SigningKeyInteger] = None
    DigestValue: Optional[SigningKeyString] = None
    Flag: Optional[SigningKeyInteger] = None
    KeyTag: Optional[SigningKeyTag] = None
    KmsArn: Optional[SigningKeyString] = None
    LastModifiedDate: Optional[TimeStamp] = None
    Name: Optional[SigningKeyName] = None
    PublicKey: Optional[SigningKeyString] = None
    SigningAlgorithmMnemonic: Optional[SigningKeyString] = None
    SigningAlgorithmType: Optional[SigningKeyInteger] = None
    Status: Optional[SigningKeyStatus] = None
    StatusMessage: Optional[SigningKeyStatusMessage] = None


class KeySigningKeys(RootModel[List[KeySigningKey]]):
    root: List[KeySigningKey]


class LinkedService(BaseModel):
    Description: Optional[ResourceDescription] = None
    ServicePrincipal_1: Optional[ServicePrincipal] = Field(
        None, alias='ServicePrincipal'
    )


class ListGeoLocationsResponse(BaseModel):
    GeoLocationDetailsList_1: GeoLocationDetailsList = Field(
        ..., alias='GeoLocationDetailsList'
    )
    IsTruncated: PageTruncated
    MaxItems: PageMaxItems
    NextContinentCode: Optional[GeoLocationContinentCode] = None
    NextCountryCode: Optional[GeoLocationCountryCode] = None
    NextSubdivisionCode: Optional[GeoLocationSubdivisionCode] = None


class ListReusableDelegationSetsResponse(BaseModel):
    DelegationSets_1: DelegationSets = Field(..., alias='DelegationSets')
    IsTruncated: PageTruncated
    Marker: PageMarker
    MaxItems: PageMaxItems
    NextMarker: Optional[PageMarker] = None


class ListTagsForResourcesRequest(BaseModel):
    ResourceIds: TagResourceIdList


class LocationSummaries(RootModel[List[LocationSummary]]):
    root: List[LocationSummary]


class QueryLoggingConfig(BaseModel):
    CloudWatchLogsLogGroupArn_1: CloudWatchLogsLogGroupArn = Field(
        ..., alias='CloudWatchLogsLogGroupArn'
    )
    HostedZoneId: ResourceId
    Id: QueryLoggingConfigId


class QueryLoggingConfigs(RootModel[List[QueryLoggingConfig]]):
    root: List[QueryLoggingConfig]


class RecordData(RootModel[List[RecordDataEntry]]):
    root: List[RecordDataEntry]


class ResourceRecordSet(BaseModel):
    AliasTarget_1: Optional[AliasTarget] = Field(None, alias='AliasTarget')
    CidrRoutingConfig_1: Optional[CidrRoutingConfig] = Field(
        None, alias='CidrRoutingConfig'
    )
    Failover: Optional[ResourceRecordSetFailover] = None
    GeoLocation_1: Optional[GeoLocation] = Field(None, alias='GeoLocation')
    HealthCheckId_1: Optional[HealthCheckId] = Field(None, alias='HealthCheckId')
    MultiValueAnswer: Optional[ResourceRecordSetMultiValueAnswer] = None
    Name: DNSName
    Region: Optional[ResourceRecordSetRegion] = None
    ResourceRecords_1: Optional[ResourceRecords] = Field(None, alias='ResourceRecords')
    SetIdentifier: Optional[ResourceRecordSetIdentifier] = None
    TTL_1: Optional[TTL] = Field(None, alias='TTL')
    TrafficPolicyInstanceId_1: Optional[TrafficPolicyInstanceId] = Field(
        None, alias='TrafficPolicyInstanceId'
    )
    Type: RRType
    Weight: Optional[ResourceRecordSetWeight] = None


class ResourceRecordSets(RootModel[List[ResourceRecordSet]]):
    root: List[ResourceRecordSet]


class ReusableDelegationSetLimit(BaseModel):
    Type: ReusableDelegationSetLimitType
    Value: LimitValue


class StatusReport(BaseModel):
    CheckedTime: Optional[TimeStamp] = None
    Status_1: Optional[Status] = Field(None, alias='Status')


class Tag(BaseModel):
    Key: Optional[TagKey] = None
    Value: Optional[TagValue] = None


class TagList(RootModel[List[Tag]]):
    root: List[Tag] = Field(..., max_length=10, min_length=1)


class TestDNSAnswerResponse(BaseModel):
    Nameserver_1: Nameserver = Field(..., alias='Nameserver')
    Protocol: TransportProtocol
    RecordData_1: RecordData = Field(..., alias='RecordData')
    RecordName: DNSName
    RecordType: RRType
    ResponseCode: DNSRCode


class TrafficPolicy(BaseModel):
    Comment: Optional[TrafficPolicyComment] = None
    Document: TrafficPolicyDocument
    Id: TrafficPolicyId
    Name: TrafficPolicyName
    Type: RRType
    Version: TrafficPolicyVersion


class TrafficPolicyInstance(BaseModel):
    HostedZoneId: ResourceId
    Id: TrafficPolicyInstanceId
    Message_1: Message = Field(..., alias='Message')
    Name: DNSName
    State: TrafficPolicyInstanceState
    TTL_1: TTL = Field(..., alias='TTL')
    TrafficPolicyId_1: TrafficPolicyId = Field(..., alias='TrafficPolicyId')
    TrafficPolicyType: RRType
    TrafficPolicyVersion_1: TrafficPolicyVersion = Field(
        ..., alias='TrafficPolicyVersion'
    )


class TrafficPolicyInstances(RootModel[List[TrafficPolicyInstance]]):
    root: List[TrafficPolicyInstance]


class TrafficPolicySummary(BaseModel):
    Id: TrafficPolicyId
    LatestVersion: TrafficPolicyVersion
    Name: TrafficPolicyName
    TrafficPolicyCount: TrafficPolicyVersion
    Type: RRType


class UpdateHealthCheckRequest(BaseModel):
    AlarmIdentifier_1: Optional[AlarmIdentifier] = Field(None, alias='AlarmIdentifier')
    ChildHealthChecks: Optional[ChildHealthCheckList] = None
    Disabled_1: Optional[Disabled] = Field(None, alias='Disabled')
    EnableSNI_1: Optional[EnableSNI] = Field(None, alias='EnableSNI')
    FailureThreshold_1: Optional[FailureThreshold] = Field(
        None, alias='FailureThreshold'
    )
    FullyQualifiedDomainName_1: Optional[FullyQualifiedDomainName] = Field(
        None, alias='FullyQualifiedDomainName'
    )
    HealthCheckVersion_1: Optional[HealthCheckVersion] = Field(
        None, alias='HealthCheckVersion'
    )
    HealthThreshold_1: Optional[HealthThreshold] = Field(None, alias='HealthThreshold')
    IPAddress_1: Optional[IPAddress] = Field(None, alias='IPAddress')
    InsufficientDataHealthStatus_1: Optional[InsufficientDataHealthStatus] = Field(
        None, alias='InsufficientDataHealthStatus'
    )
    Inverted_1: Optional[Inverted] = Field(None, alias='Inverted')
    Port_1: Optional[Port] = Field(None, alias='Port')
    Regions: Optional[HealthCheckRegionList] = None
    ResetElements: Optional[ResettableElementNameList] = None
    ResourcePath_1: Optional[ResourcePath] = Field(None, alias='ResourcePath')
    SearchString_1: Optional[SearchString] = Field(None, alias='SearchString')


class UpdateTrafficPolicyCommentResponse(BaseModel):
    TrafficPolicy_1: TrafficPolicy = Field(..., alias='TrafficPolicy')


class UpdateTrafficPolicyInstanceResponse(BaseModel):
    TrafficPolicyInstance_1: TrafficPolicyInstance = Field(
        ..., alias='TrafficPolicyInstance'
    )


class VPCs(RootModel[List[VPC]]):
    root: List[VPC] = Field(
        ...,
        description='(Private hosted zones only) A list of <code>VPC</code> elements.',
        min_length=1,
    )


class Field20130401CidrcollectionCidrCollectionIdPostRequest(BaseModel):
    Changes: List[CidrCollectionChange] = Field(
        ...,
        description=' Information about changes to a CIDR collection.',
        max_length=1000,
        min_length=1,
    )
    CollectionVersion: Optional[conint(ge=1)] = Field(
        None,
        description='<p>A sequential counter that Amazon Route\xa053 sets to 1 when you create a collection and increments it by 1 each time you update the collection.</p> <p>We recommend that you use <code>ListCidrCollection</code> to get the current value of <code>CollectionVersion</code> for the collection that you want to update, and then include that value with the change request. This prevents Route\xa053 from overwriting an intervening update: </p> <ul> <li> <p>If the value in the request matches the value of <code>CollectionVersion</code> in the collection, Route\xa053 updates the collection.</p> </li> <li> <p>If the value of <code>CollectionVersion</code> in the collection is greater than the value in the request, the collection was changed after you got the version number. Route\xa053 does not update the collection, and it returns a <code>CidrCollectionVersionMismatch</code> error. </p> </li> </ul>',
    )


class HealthCheckConfig1(BaseModel):
    AlarmIdentifier_1: Optional[AlarmIdentifier] = Field(None, alias='AlarmIdentifier')
    ChildHealthChecks: Optional[ChildHealthCheckList] = None
    Disabled_1: Optional[Disabled] = Field(None, alias='Disabled')
    EnableSNI_1: Optional[EnableSNI] = Field(None, alias='EnableSNI')
    FailureThreshold_1: Optional[FailureThreshold] = Field(
        None, alias='FailureThreshold'
    )
    FullyQualifiedDomainName_1: Optional[FullyQualifiedDomainName] = Field(
        None, alias='FullyQualifiedDomainName'
    )
    HealthThreshold_1: Optional[HealthThreshold] = Field(None, alias='HealthThreshold')
    IPAddress_1: Optional[IPAddress] = Field(None, alias='IPAddress')
    InsufficientDataHealthStatus_1: Optional[InsufficientDataHealthStatus] = Field(
        None, alias='InsufficientDataHealthStatus'
    )
    Inverted_1: Optional[Inverted] = Field(None, alias='Inverted')
    MeasureLatency_1: Optional[MeasureLatency] = Field(None, alias='MeasureLatency')
    Port_1: Optional[Port] = Field(None, alias='Port')
    Regions: Optional[HealthCheckRegionList] = None
    RequestInterval_1: Optional[RequestInterval] = Field(None, alias='RequestInterval')
    ResourcePath_1: Optional[ResourcePath] = Field(None, alias='ResourcePath')
    RoutingControlArn_1: Optional[RoutingControlArn] = Field(
        None, alias='RoutingControlArn'
    )
    SearchString_1: Optional[SearchString] = Field(None, alias='SearchString')
    Type: Optional[HealthCheckType] = None


class Field20130401HealthcheckPostRequest(BaseModel):
    CallerReference: constr(min_length=1, max_length=64) = Field(
        ...,
        description="<p>A unique string that identifies the request and that allows you to retry a failed <code>CreateHealthCheck</code> request without the risk of creating two identical health checks:</p> <ul> <li> <p>If you send a <code>CreateHealthCheck</code> request with the same <code>CallerReference</code> and settings as a previous request, and if the health check doesn't exist, Amazon Route 53 creates the health check. If the health check does exist, Route 53 returns the settings for the existing health check.</p> </li> <li> <p>If you send a <code>CreateHealthCheck</code> request with the same <code>CallerReference</code> as a deleted health check, regardless of the settings, Route 53 returns a <code>HealthCheckAlreadyExists</code> error.</p> </li> <li> <p>If you send a <code>CreateHealthCheck</code> request with the same <code>CallerReference</code> as an existing health check but with different settings, Route 53 returns a <code>HealthCheckAlreadyExists</code> error.</p> </li> <li> <p>If you send a <code>CreateHealthCheck</code> request with a unique <code>CallerReference</code> but settings identical to an existing health check, Route 53 creates the health check.</p> </li> </ul>",
    )
    HealthCheckConfig: HealthCheckConfig1 = Field(
        ...,
        description='A complex type that contains information about the health check.',
    )


class Field20130401TagsResourceTypeResourceIdPostRequest(BaseModel):
    AddTags: Optional[List[Tag]] = Field(
        None,
        description='<p>A complex type that contains a list of the tags that you want to add to the specified health check or hosted zone and/or the tags that you want to edit <code>Value</code> for.</p> <p>You can add a maximum of 10 tags to a health check or a hosted zone.</p>',
        max_length=10,
        min_length=1,
    )
    RemoveTagKeys: Optional[List[TagKey]] = Field(
        None,
        description='A complex type that contains a list of the tags that you want to delete from the specified health check or hosted zone. You can specify up to 10 keys.',
        max_length=10,
        min_length=1,
    )


class ActivateKeySigningKeyResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class AssociateVPCWithHostedZoneRequest(BaseModel):
    Comment: Optional[AssociateVPCComment] = None
    VPC_1: VPC = Field(..., alias='VPC')


class AssociateVPCWithHostedZoneResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')


class Change(BaseModel):
    Action: ChangeAction
    ResourceRecordSet_1: ResourceRecordSet = Field(..., alias='ResourceRecordSet')


class ChangeCidrCollectionRequest(BaseModel):
    Changes: CidrCollectionChanges
    CollectionVersion_1: Optional[CollectionVersion] = Field(
        None, alias='CollectionVersion'
    )


class ChangeTagsForResourceRequest(BaseModel):
    AddTags: Optional[TagList] = None
    RemoveTagKeys: Optional[TagKeyList] = None


class Changes(RootModel[List[Change]]):
    root: List[Change] = Field(..., min_length=1)


class CidrBlockSummaries(RootModel[List[CidrBlockSummary]]):
    root: List[CidrBlockSummary]


class CloudWatchAlarmConfiguration(BaseModel):
    ComparisonOperator_1: ComparisonOperator = Field(..., alias='ComparisonOperator')
    Dimensions: Optional[DimensionList] = None
    EvaluationPeriods_1: EvaluationPeriods = Field(..., alias='EvaluationPeriods')
    MetricName_1: MetricName = Field(..., alias='MetricName')
    Namespace_1: Namespace = Field(..., alias='Namespace')
    Period_1: Period = Field(..., alias='Period')
    Statistic_1: Statistic = Field(..., alias='Statistic')
    Threshold_1: Threshold = Field(..., alias='Threshold')


class CollectionSummaries(RootModel[List[CollectionSummary]]):
    root: List[CollectionSummary]


class CreateHealthCheckRequest(BaseModel):
    CallerReference: HealthCheckNonce
    HealthCheckConfig_1: HealthCheckConfig = Field(..., alias='HealthCheckConfig')


class CreateHostedZoneRequest(BaseModel):
    CallerReference: Nonce
    DelegationSetId: Optional[ResourceId] = None
    HostedZoneConfig_1: Optional[HostedZoneConfig] = Field(
        None, alias='HostedZoneConfig'
    )
    Name: DNSName
    VPC_1: Optional[VPC] = Field(None, alias='VPC')


class CreateKeySigningKeyResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')
    KeySigningKey_1: KeySigningKey = Field(..., alias='KeySigningKey')


class CreateQueryLoggingConfigResponse(BaseModel):
    QueryLoggingConfig_1: QueryLoggingConfig = Field(..., alias='QueryLoggingConfig')


class CreateReusableDelegationSetResponse(BaseModel):
    DelegationSet_1: DelegationSet = Field(..., alias='DelegationSet')


class CreateTrafficPolicyInstanceResponse(BaseModel):
    TrafficPolicyInstance_1: TrafficPolicyInstance = Field(
        ..., alias='TrafficPolicyInstance'
    )


class CreateTrafficPolicyResponse(BaseModel):
    TrafficPolicy_1: TrafficPolicy = Field(..., alias='TrafficPolicy')


class CreateTrafficPolicyVersionResponse(BaseModel):
    TrafficPolicy_1: TrafficPolicy = Field(..., alias='TrafficPolicy')


class CreateVPCAssociationAuthorizationRequest(BaseModel):
    VPC_1: VPC = Field(..., alias='VPC')


class CreateVPCAssociationAuthorizationResponse(BaseModel):
    HostedZoneId: ResourceId
    VPC_1: VPC = Field(..., alias='VPC')


class DeleteVPCAssociationAuthorizationRequest(BaseModel):
    VPC_1: VPC = Field(..., alias='VPC')


class DisassociateVPCFromHostedZoneRequest(BaseModel):
    Comment: Optional[DisassociateVPCComment] = None
    VPC_1: VPC = Field(..., alias='VPC')


class GetDNSSECResponse(BaseModel):
    KeySigningKeys_1: KeySigningKeys = Field(..., alias='KeySigningKeys')
    Status: DNSSECStatus


class GetHostedZoneLimitResponse(BaseModel):
    Count: UsageCount
    Limit: HostedZoneLimit


class GetQueryLoggingConfigResponse(BaseModel):
    QueryLoggingConfig_1: QueryLoggingConfig = Field(..., alias='QueryLoggingConfig')


class GetReusableDelegationSetLimitResponse(BaseModel):
    Count: UsageCount
    Limit: ReusableDelegationSetLimit


class GetTrafficPolicyInstanceResponse(BaseModel):
    TrafficPolicyInstance_1: TrafficPolicyInstance = Field(
        ..., alias='TrafficPolicyInstance'
    )


class GetTrafficPolicyResponse(BaseModel):
    TrafficPolicy_1: TrafficPolicy = Field(..., alias='TrafficPolicy')


class HealthCheck(BaseModel):
    CallerReference: HealthCheckNonce
    CloudWatchAlarmConfiguration_1: Optional[CloudWatchAlarmConfiguration] = Field(
        None, alias='CloudWatchAlarmConfiguration'
    )
    HealthCheckConfig_1: HealthCheckConfig = Field(..., alias='HealthCheckConfig')
    HealthCheckVersion_1: HealthCheckVersion = Field(..., alias='HealthCheckVersion')
    Id: HealthCheckId
    LinkedService_1: Optional[LinkedService] = Field(None, alias='LinkedService')


class HealthCheckObservation(BaseModel):
    IPAddress_1: Optional[IPAddress] = Field(None, alias='IPAddress')
    Region: Optional[HealthCheckRegion] = None
    StatusReport_1: Optional[StatusReport] = Field(None, alias='StatusReport')


class HealthCheckObservations(RootModel[List[HealthCheckObservation]]):
    root: List[HealthCheckObservation]


class HealthChecks(RootModel[List[HealthCheck]]):
    root: List[HealthCheck]


class HostedZone(BaseModel):
    CallerReference: Nonce
    Config: Optional[HostedZoneConfig] = None
    Id: ResourceId
    LinkedService_1: Optional[LinkedService] = Field(None, alias='LinkedService')
    Name: DNSName
    ResourceRecordSetCount: Optional[HostedZoneRRSetCount] = None


class HostedZoneSummaries(RootModel[List[HostedZoneSummary]]):
    root: List[HostedZoneSummary]


class HostedZones(RootModel[List[HostedZone]]):
    root: List[HostedZone]


class ListCidrBlocksResponse(BaseModel):
    CidrBlocks: Optional[CidrBlockSummaries] = None
    NextToken: Optional[PaginationToken] = None


class ListCidrCollectionsResponse(BaseModel):
    CidrCollections: Optional[CollectionSummaries] = None
    NextToken: Optional[PaginationToken] = None


class ListCidrLocationsResponse(BaseModel):
    CidrLocations: Optional[LocationSummaries] = None
    NextToken: Optional[PaginationToken] = None


class ListHealthChecksResponse(BaseModel):
    HealthChecks_1: HealthChecks = Field(..., alias='HealthChecks')
    IsTruncated: PageTruncated
    Marker: PageMarker
    MaxItems: PageMaxItems
    NextMarker: Optional[PageMarker] = None


class ListHostedZonesByNameResponse(BaseModel):
    DNSName_1: Optional[DNSName] = Field(None, alias='DNSName')
    HostedZoneId: Optional[ResourceId] = None
    HostedZones_1: HostedZones = Field(..., alias='HostedZones')
    IsTruncated: PageTruncated
    MaxItems: PageMaxItems
    NextDNSName: Optional[DNSName] = None
    NextHostedZoneId: Optional[ResourceId] = None


class ListHostedZonesByVPCResponse(BaseModel):
    HostedZoneSummaries_1: HostedZoneSummaries = Field(..., alias='HostedZoneSummaries')
    MaxItems: PageMaxItems
    NextToken: Optional[PaginationToken] = None


class ListHostedZonesResponse(BaseModel):
    HostedZones_1: HostedZones = Field(..., alias='HostedZones')
    IsTruncated: PageTruncated
    Marker: PageMarker
    MaxItems: PageMaxItems
    NextMarker: Optional[PageMarker] = None


class ListQueryLoggingConfigsResponse(BaseModel):
    NextToken: Optional[PaginationToken] = None
    QueryLoggingConfigs_1: QueryLoggingConfigs = Field(..., alias='QueryLoggingConfigs')


class ListResourceRecordSetsResponse(BaseModel):
    IsTruncated: PageTruncated
    MaxItems: PageMaxItems
    NextRecordIdentifier: Optional[ResourceRecordSetIdentifier] = None
    NextRecordName: Optional[DNSName] = None
    NextRecordType: Optional[RRType] = None
    ResourceRecordSets_1: ResourceRecordSets = Field(..., alias='ResourceRecordSets')


class ListTrafficPolicyInstancesByHostedZoneResponse(BaseModel):
    IsTruncated: PageTruncated
    MaxItems: PageMaxItems
    TrafficPolicyInstanceNameMarker: Optional[DNSName] = None
    TrafficPolicyInstanceTypeMarker: Optional[RRType] = None
    TrafficPolicyInstances_1: TrafficPolicyInstances = Field(
        ..., alias='TrafficPolicyInstances'
    )


class ListTrafficPolicyInstancesByPolicyResponse(BaseModel):
    HostedZoneIdMarker: Optional[ResourceId] = None
    IsTruncated: PageTruncated
    MaxItems: PageMaxItems
    TrafficPolicyInstanceNameMarker: Optional[DNSName] = None
    TrafficPolicyInstanceTypeMarker: Optional[RRType] = None
    TrafficPolicyInstances_1: TrafficPolicyInstances = Field(
        ..., alias='TrafficPolicyInstances'
    )


class ListTrafficPolicyInstancesResponse(BaseModel):
    HostedZoneIdMarker: Optional[ResourceId] = None
    IsTruncated: PageTruncated
    MaxItems: PageMaxItems
    TrafficPolicyInstanceNameMarker: Optional[DNSName] = None
    TrafficPolicyInstanceTypeMarker: Optional[RRType] = None
    TrafficPolicyInstances_1: TrafficPolicyInstances = Field(
        ..., alias='TrafficPolicyInstances'
    )


class ListVPCAssociationAuthorizationsResponse(BaseModel):
    HostedZoneId: ResourceId
    NextToken: Optional[PaginationToken] = None
    VPCs_1: VPCs = Field(..., alias='VPCs')


class ResourceTagSet(BaseModel):
    ResourceId: Optional[TagResourceId] = None
    ResourceType: Optional[TagResourceType] = None
    Tags: Optional[TagList] = None


class ResourceTagSetList(RootModel[List[ResourceTagSet]]):
    root: List[ResourceTagSet]


class TrafficPolicies(RootModel[List[TrafficPolicy]]):
    root: List[TrafficPolicy]


class TrafficPolicySummaries(RootModel[List[TrafficPolicySummary]]):
    root: List[TrafficPolicySummary]


class UpdateHealthCheckResponse(BaseModel):
    HealthCheck_1: HealthCheck = Field(..., alias='HealthCheck')


class UpdateHostedZoneCommentResponse(BaseModel):
    HostedZone_1: HostedZone = Field(..., alias='HostedZone')


class ChangeBatch1(BaseModel):
    Changes_1: Optional[Changes] = Field(None, alias='Changes')
    Comment: Optional[ResourceDescription] = None


class Field20130401HostedzoneIdRrsetPostRequest(BaseModel):
    ChangeBatch: ChangeBatch1 = Field(
        ..., description='The information for a change request.'
    )


class ChangeBatch(BaseModel):
    Changes_1: Changes = Field(..., alias='Changes')
    Comment: Optional[ResourceDescription] = None


class ChangeResourceRecordSetsRequest(BaseModel):
    ChangeBatch_1: ChangeBatch = Field(..., alias='ChangeBatch')


class CreateHealthCheckResponse(BaseModel):
    HealthCheck_1: HealthCheck = Field(..., alias='HealthCheck')


class CreateHostedZoneResponse(BaseModel):
    ChangeInfo_1: ChangeInfo = Field(..., alias='ChangeInfo')
    DelegationSet_1: DelegationSet = Field(..., alias='DelegationSet')
    HostedZone_1: HostedZone = Field(..., alias='HostedZone')
    VPC_1: Optional[VPC] = Field(None, alias='VPC')


class GetHealthCheckLastFailureReasonResponse(BaseModel):
    HealthCheckObservations_1: HealthCheckObservations = Field(
        ..., alias='HealthCheckObservations'
    )


class GetHealthCheckResponse(BaseModel):
    HealthCheck_1: HealthCheck = Field(..., alias='HealthCheck')


class GetHealthCheckStatusResponse(BaseModel):
    HealthCheckObservations_1: HealthCheckObservations = Field(
        ..., alias='HealthCheckObservations'
    )


class GetHostedZoneResponse(BaseModel):
    DelegationSet_1: Optional[DelegationSet] = Field(None, alias='DelegationSet')
    HostedZone_1: HostedZone = Field(..., alias='HostedZone')
    VPCs_1: Optional[VPCs] = Field(None, alias='VPCs')


class ListTagsForResourceResponse(BaseModel):
    ResourceTagSet_1: ResourceTagSet = Field(..., alias='ResourceTagSet')


class ListTagsForResourcesResponse(BaseModel):
    ResourceTagSets: ResourceTagSetList


class ListTrafficPoliciesResponse(BaseModel):
    IsTruncated: PageTruncated
    MaxItems: PageMaxItems
    TrafficPolicyIdMarker: TrafficPolicyId
    TrafficPolicySummaries_1: TrafficPolicySummaries = Field(
        ..., alias='TrafficPolicySummaries'
    )


class ListTrafficPolicyVersionsResponse(BaseModel):
    IsTruncated: PageTruncated
    MaxItems: PageMaxItems
    TrafficPolicies_1: TrafficPolicies = Field(..., alias='TrafficPolicies')
    TrafficPolicyVersionMarker_1: TrafficPolicyVersionMarker = Field(
        ..., alias='TrafficPolicyVersionMarker'
    )
